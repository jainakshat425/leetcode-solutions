class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        DSU dsu = new DSU(n);
        int[] infected = new int[n];
        
        // 0 is not infected, 1 is infected.
        for(int u : initial) 
            infected[u] = 1;
        
        // Group clean nodes using DSU
        for(int i=0; i<n; i++) {
            
            if( infected[i] == 1 ) 
                continue;
            
            for(int j=i+1; j<n; j++) {
                if( graph[i][j] == 1 && infected[j] == 0 )
                    dsu.union(i, j);
            }
        }        
        
        /* Find root for each neighbour node of infected node, and store
        the mapping - infectedNode -> root of neighbour nodes. */
        
        Map<Integer,Set<Integer>> infectedToRoots = new HashMap();
        
        // Stores count of infected node in current component
        int[] infectedCount = new int[n];
        
        for(int u : initial) {
            
            Set<Integer> roots = new HashSet();
            infectedToRoots.put(u, roots);
            
            for(int v=0; v<n; v++) {
                int root = dsu.find(v);
                
                if( graph[u][v] == 1 && infected[v] == 0 && !roots.contains(root)) {
                    roots.add( root );
                    infectedCount[root]++;
                }
            }
        }
        
        int ansNode = -1;
        int maxSize = 0;
        int minNode = Integer.MAX_VALUE;
        
        for(int u : initial) {
            Set<Integer> roots = infectedToRoots.get(u);
            
            int total = 0;
            for(int root : roots) {
                // If the component at root contains only one infected node
                if( infectedCount[root] == 1 ) {
                    total += dsu.size(root);
                } 
            }

            if( total > maxSize ) {
                ansNode = u;
                maxSize = total;
            } else if( total == maxSize && u < ansNode ) 
                ansNode = u;
            
            minNode = Math.min(minNode, u);
        }
        
        return ansNode != -1 ? ansNode : minNode;
    }
}

class DSU {
    private int[] parent;
    private int[] size;
    
    public DSU(int n) {
        parent = new int[n];
        size = new int[n];
        
        for(int i=0; i<n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public int find(int node) {
        if( parent[node] != node )
            parent[node] = find(parent[node]);
        return parent[node];
    }
    
    public void union(int node1, int node2) {
        int root1 = find(node1);
        int root2 = find(node2);
        
        if( size[root2] > size[root1] ) {
            parent[root1] = root2;
            size[root2] += size[root1];
        } else {
            parent[root2] = root1;
            size[root1] += size[root2];
        }
    }
    
    public int size(int node) {
        return size[find(node)];
    }
}
